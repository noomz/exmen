---
phase: 03-script-execution
plan: 01
type: execute
depends_on: []
files_modified: [Exmen/Services/ScriptRunner.swift, Exmen/Models/ScriptResult.swift]
---

<objective>
Create the script execution engine using Swift's Process API.

Purpose: Enable running bash scripts (inline or from file) and capturing their output.
Output: ScriptRunner service that executes scripts asynchronously and returns results.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-plan.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-config-discovery/02-02-SUMMARY.md

**Key requirements:**
- Execute inline scripts (content in TOML)
- Execute file-based scripts (path in TOML)
- Capture stdout and stderr
- Handle script errors gracefully
- Run asynchronously to not block UI
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ScriptResult model</name>
  <files>Exmen/Models/ScriptResult.swift</files>
  <action>
Create a model to represent script execution results:

```swift
import Foundation

/// Result of a script execution
struct ScriptResult {
    let output: String
    let error: String
    let exitCode: Int32
    let duration: TimeInterval

    /// Whether the script succeeded (exit code 0)
    var isSuccess: Bool {
        exitCode == 0
    }

    /// Combined output (stdout + stderr if any)
    var combinedOutput: String {
        if error.isEmpty {
            return output
        } else if output.isEmpty {
            return error
        } else {
            return output + "\n" + error
        }
    }

    /// Trimmed output (removes trailing whitespace/newlines)
    var trimmedOutput: String {
        output.trimmingCharacters(in: .whitespacesAndNewlines)
    }
}

/// Errors that can occur during script execution
enum ScriptError: Error, LocalizedError {
    case noScriptContent
    case scriptFileNotFound(String)
    case executionFailed(String)
    case timeout

    var errorDescription: String? {
        switch self {
        case .noScriptContent:
            return "No script content provided"
        case .scriptFileNotFound(let path):
            return "Script file not found: \(path)"
        case .executionFailed(let message):
            return "Execution failed: \(message)"
        case .timeout:
            return "Script execution timed out"
        }
    }
}
```
  </action>
  <verify>ScriptResult.swift exists with ScriptResult struct and ScriptError enum</verify>
  <done>ScriptResult model created</done>
</task>

<task type="auto">
  <name>Task 2: Create ScriptRunner service</name>
  <files>Exmen/Services/ScriptRunner.swift</files>
  <action>
Create the script execution service:

```swift
import Foundation

/// Service for executing shell scripts
class ScriptRunner {
    static let shared = ScriptRunner()

    /// Default timeout for script execution (30 seconds)
    let defaultTimeout: TimeInterval = 30.0

    private init() {}

    /// Execute a script from ScriptConfig
    func run(_ config: ScriptConfig, timeout: TimeInterval? = nil) async throws -> ScriptResult {
        guard let content = config.resolvedContent() else {
            if config.type == .file {
                throw ScriptError.scriptFileNotFound(config.path ?? "unknown")
            }
            throw ScriptError.noScriptContent
        }

        return try await runScript(content, timeout: timeout ?? defaultTimeout)
    }

    /// Execute a script string directly
    func runScript(_ script: String, timeout: TimeInterval? = nil) async throws -> ScriptResult {
        let startTime = Date()
        let effectiveTimeout = timeout ?? defaultTimeout

        return try await withCheckedThrowingContinuation { continuation in
            let process = Process()
            let outputPipe = Pipe()
            let errorPipe = Pipe()

            process.executableURL = URL(fileURLWithPath: "/bin/bash")
            process.arguments = ["-c", script]
            process.standardOutput = outputPipe
            process.standardError = errorPipe

            // Set up environment
            var environment = ProcessInfo.processInfo.environment
            environment["PATH"] = "/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/opt/homebrew/bin"
            process.environment = environment

            // Timeout handling
            let timeoutWorkItem = DispatchWorkItem {
                if process.isRunning {
                    process.terminate()
                    continuation.resume(throwing: ScriptError.timeout)
                }
            }

            DispatchQueue.global().asyncAfter(
                deadline: .now() + effectiveTimeout,
                execute: timeoutWorkItem
            )

            process.terminationHandler = { [weak outputPipe, weak errorPipe] proc in
                timeoutWorkItem.cancel()

                let outputData = outputPipe?.fileHandleForReading.readDataToEndOfFile() ?? Data()
                let errorData = errorPipe?.fileHandleForReading.readDataToEndOfFile() ?? Data()

                let output = String(data: outputData, encoding: .utf8) ?? ""
                let error = String(data: errorData, encoding: .utf8) ?? ""
                let duration = Date().timeIntervalSince(startTime)

                let result = ScriptResult(
                    output: output,
                    error: error,
                    exitCode: proc.terminationStatus,
                    duration: duration
                )

                continuation.resume(returning: result)
            }

            do {
                try process.run()
            } catch {
                timeoutWorkItem.cancel()
                continuation.resume(throwing: ScriptError.executionFailed(error.localizedDescription))
            }
        }
    }
}
```
  </action>
  <verify>ScriptRunner.swift exists with run() and runScript() async methods</verify>
  <done>ScriptRunner service created with async execution</done>
</task>

<task type="auto">
  <name>Task 3: Update Xcode project with new files</name>
  <files>Exmen.xcodeproj/project.pbxproj</files>
  <action>
Add ScriptResult.swift and ScriptRunner.swift to the Xcode project.

Update the project.pbxproj to include:
- ScriptResult.swift in Models group
- ScriptRunner.swift in Services group
  </action>
  <verify>Both files appear in Xcode project and build succeeds</verify>
  <done>Xcode project updated with new files</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] ScriptResult.swift exists with result model and error enum
- [ ] ScriptRunner.swift exists with async execution
- [ ] Files added to Xcode project
- [ ] Project builds successfully
</verification>

<success_criteria>
- All tasks completed
- Can execute inline scripts
- Can execute file-based scripts
- Captures stdout, stderr, exit code
- Handles timeouts gracefully
- Async execution doesn't block UI
</success_criteria>

<output>
After completion, create `.planning/phases/03-script-execution/03-01-SUMMARY.md`
</output>
