---
phase: 02-config-discovery
plan: 01
type: execute
depends_on: []
files_modified: [Package.swift, Exmen/Models/Action.swift, Exmen/Models/ActionConfig.swift, Exmen/Services/ConfigLoader.swift]
---

<objective>
Add TOMLDecoder dependency and create config models for loading actions from TOML files.

Purpose: Enable the app to read action definitions from TOML config files instead of hardcoded samples.
Output: ActionConfig Codable struct and ConfigLoader service that can parse TOML files.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-plan.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-config-discovery/02-RESEARCH.md
@.planning/phases/01-foundation/01-02-SUMMARY.md

**From RESEARCH.md:**
- Use TOMLDecoder (dduan) - pure Swift, faster than C
- Codable structs for ActionConfig, ScriptConfig, OutputConfig
- Script types: "inline" (content in TOML) or "file" (path to script)
- Output handlers: "clipboard", "notification", "popup"
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add TOMLDecoder Swift Package dependency</name>
  <files>Package.swift, Exmen.xcodeproj/project.pbxproj</files>
  <action>
Create Package.swift for Swift Package Manager:

```swift
// swift-tools-version: 5.9
import PackageDescription

let package = Package(
    name: "Exmen",
    platforms: [.macOS(.v13)],
    dependencies: [
        .package(url: "https://github.com/dduan/TOMLDecoder", from: "0.4.0")
    ],
    targets: [
        .executableTarget(
            name: "Exmen",
            dependencies: ["TOMLDecoder"],
            path: "Exmen"
        )
    ]
)
```

Note: For Xcode project, we'll add the package via Xcode's SPM integration by updating the project file or using `xcodebuild -resolvePackageDependencies`.
  </action>
  <verify>Package.swift exists with TOMLDecoder dependency</verify>
  <done>TOMLDecoder dependency added to project</done>
</task>

<task type="auto">
  <name>Task 2: Create ActionConfig Codable models</name>
  <files>Exmen/Models/ActionConfig.swift</files>
  <action>
Create the Codable structs for parsing TOML config:

```swift
import Foundation

/// Script execution type
enum ScriptType: String, Codable {
    case inline  // Script content embedded in TOML
    case file    // Path to external script file
}

/// Output handling method
enum OutputHandler: String, Codable {
    case clipboard     // Copy output to clipboard
    case notification  // Show macOS notification
    case popup         // Show in popup window
}

/// Script configuration from TOML
struct ScriptConfig: Codable {
    let type: ScriptType
    let content: String?  // For inline scripts
    let path: String?     // For file scripts

    /// Get the script content, reading from file if needed
    func resolvedContent() -> String? {
        switch type {
        case .inline:
            return content
        case .file:
            guard let path = path else { return nil }
            let expandedPath = NSString(string: path).expandingTildeInPath
            return try? String(contentsOfFile: expandedPath, encoding: .utf8)
        }
    }
}

/// Output configuration from TOML
struct OutputConfig: Codable {
    let handler: OutputHandler

    init(handler: OutputHandler = .clipboard) {
        self.handler = handler
    }
}

/// Full action configuration from TOML file
struct ActionConfig: Codable {
    let name: String
    let icon: String?
    let description: String?
    let script: ScriptConfig
    let output: OutputConfig?

    /// Default output handler if not specified
    var resolvedOutput: OutputConfig {
        output ?? OutputConfig(handler: .clipboard)
    }
}
```
  </action>
  <verify>ActionConfig.swift exists with ScriptType, OutputHandler, ScriptConfig, OutputConfig, ActionConfig</verify>
  <done>ActionConfig Codable models created for TOML parsing</done>
</task>

<task type="auto">
  <name>Task 3: Create ConfigLoader service</name>
  <files>Exmen/Services/ConfigLoader.swift</files>
  <action>
Create the service to load TOML configs:

```swift
import Foundation
import TOMLDecoder

/// Errors that can occur when loading configs
enum ConfigError: Error {
    case directoryNotFound(String)
    case invalidTOML(String, Error)
    case noActionsFound
}

/// Service to load action configs from TOML files
class ConfigLoader {
    static let shared = ConfigLoader()

    /// Default config directory
    let configDirectory: String

    init(configDirectory: String = "~/.config/exmen/actions") {
        self.configDirectory = NSString(string: configDirectory).expandingTildeInPath
    }

    /// Load all action configs from the config directory
    func loadAllConfigs() -> [ActionConfig] {
        let fileManager = FileManager.default

        // Check if directory exists
        var isDirectory: ObjCBool = false
        guard fileManager.fileExists(atPath: configDirectory, isDirectory: &isDirectory),
              isDirectory.boolValue else {
            print("Config directory not found: \(configDirectory)")
            return []
        }

        // Get all .toml files
        guard let files = try? fileManager.contentsOfDirectory(atPath: configDirectory) else {
            return []
        }

        let tomlFiles = files.filter { $0.hasSuffix(".toml") }

        // Load each config
        return tomlFiles.compactMap { filename in
            let path = (configDirectory as NSString).appendingPathComponent(filename)
            return loadConfig(from: path)
        }
    }

    /// Load a single action config from a TOML file
    func loadConfig(from path: String) -> ActionConfig? {
        guard let data = FileManager.default.contents(atPath: path),
              let content = String(data: data, encoding: .utf8) else {
            print("Failed to read file: \(path)")
            return nil
        }

        do {
            let decoder = TOMLDecoder()
            return try decoder.decode(ActionConfig.self, from: content)
        } catch {
            print("Failed to parse TOML at \(path): \(error)")
            return nil
        }
    }

    /// Ensure config directory exists, create if needed
    func ensureConfigDirectory() -> Bool {
        let fileManager = FileManager.default

        if !fileManager.fileExists(atPath: configDirectory) {
            do {
                try fileManager.createDirectory(
                    atPath: configDirectory,
                    withIntermediateDirectories: true,
                    attributes: nil
                )
                return true
            } catch {
                print("Failed to create config directory: \(error)")
                return false
            }
        }
        return true
    }
}
```
  </action>
  <verify>ConfigLoader.swift exists with loadAllConfigs() and loadConfig(from:) methods</verify>
  <done>ConfigLoader service created for loading TOML configs</done>
</task>

<task type="auto">
  <name>Task 4: Update Action model to init from ActionConfig</name>
  <files>Exmen/Models/Action.swift</files>
  <action>
Update the Action model to support initialization from ActionConfig:

```swift
import Foundation

struct Action: Identifiable {
    let id: UUID
    let name: String
    let icon: String
    let description: String
    let scriptConfig: ScriptConfig?
    let outputConfig: OutputConfig

    init(
        id: UUID = UUID(),
        name: String,
        icon: String = "terminal",
        description: String = "",
        scriptConfig: ScriptConfig? = nil,
        outputConfig: OutputConfig = OutputConfig(handler: .clipboard)
    ) {
        self.id = id
        self.name = name
        self.icon = icon
        self.description = description
        self.scriptConfig = scriptConfig
        self.outputConfig = outputConfig
    }

    /// Initialize from ActionConfig (loaded from TOML)
    init(from config: ActionConfig) {
        self.id = UUID()
        self.name = config.name
        self.icon = config.icon ?? "terminal"
        self.description = config.description ?? ""
        self.scriptConfig = config.script
        self.outputConfig = config.resolvedOutput
    }
}

// Static sample actions for development/fallback
extension Action {
    static let samples: [Action] = [
        Action(name: "Generate Phone Number", icon: "phone", description: "Generate random phone number"),
        Action(name: "Update Homebrew", icon: "arrow.clockwise", description: "Run brew update && upgrade"),
        Action(name: "Check Disk Space", icon: "internaldrive", description: "Show available disk space")
    ]
}
```
  </action>
  <verify>Action.swift has init(from: ActionConfig) initializer</verify>
  <done>Action model updated with ActionConfig initializer</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] Package.swift exists with TOMLDecoder dependency
- [ ] ActionConfig.swift exists with all Codable structs
- [ ] ConfigLoader.swift exists with load methods
- [ ] Action.swift updated with init(from: ActionConfig)
- [ ] Project builds successfully
</verification>

<success_criteria>
- All tasks completed
- TOMLDecoder integrated
- Can parse TOML files into ActionConfig
- ConfigLoader can load from ~/.config/exmen/actions/
- Action model supports both static and config-based initialization
</success_criteria>

<output>
After completion, create `.planning/phases/02-config-discovery/02-01-SUMMARY.md`
</output>
