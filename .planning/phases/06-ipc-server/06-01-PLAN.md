---
phase: 06-ipc-server
plan: 01
type: execute
depends_on: []
files_modified: [Exmen/Services/SocketServer.swift, Exmen/Services/CommandHandler.swift, Exmen/ExmenApp.swift]
---

<objective>
Create Unix domain socket server for IPC communication.

Purpose: Allow external tools (sketchybar, scripts, CLI) to query and control Exmen.
Output: Socket server running at ~/.config/exmen/exmen.sock, handling JSON commands.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-plan.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@Exmen/Services/ActionService.swift
@Exmen/ExmenApp.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SocketServer service</name>
  <files>Exmen/Services/SocketServer.swift</files>
  <action>
  Create SocketServer class that:
  1. Uses Foundation's socket APIs (socket, bind, listen, accept)
  2. Socket path: ~/.config/exmen/exmen.sock (use FileManager to expand ~)
  3. Remove existing socket file on start (unlink if exists)
  4. Listen for connections in background thread using DispatchSource
  5. Accept connections and spawn handler for each client
  6. Read JSON from client, parse, call CommandHandler, send JSON response
  7. Clean up socket file on stop

  Use Darwin/POSIX socket APIs:
  - socket(AF_UNIX, SOCK_STREAM, 0)
  - bind() with sockaddr_un
  - listen()
  - accept() in DispatchSource.makeReadSource

  Make it @MainActor-safe for calling ActionService.
  </action>
  <verify>Build succeeds, no compiler errors</verify>
  <done>SocketServer.swift exists with start/stop methods</done>
</task>

<task type="auto">
  <name>Task 2: Create CommandHandler for routing commands</name>
  <files>Exmen/Services/CommandHandler.swift</files>
  <action>
  Create CommandHandler that:
  1. Parses JSON request: {"command": "list-actions"} or {"command": "run", "name": "..."} etc.
  2. Routes to appropriate handler method
  3. Returns JSON response: {"success": true, "data": ...} or {"success": false, "error": "..."}

  Commands to implement:
  - list-actions: Return array of {name, icon, description, status} from ActionService.shared.actions
  - run: Find action by name, call executeAction logic, return output
  - status: Find action by name, return dynamic state (dynamicTitle, dynamicStatus, etc.)

  Use Codable for JSON encoding/decoding.
  Handle errors gracefully (action not found, invalid command).
  </action>
  <verify>Build succeeds</verify>
  <done>CommandHandler handles list-actions, run, status commands</done>
</task>

<task type="auto">
  <name>Task 3: Start socket server on app launch</name>
  <files>Exmen/ExmenApp.swift</files>
  <action>
  1. Create SocketServer.shared singleton
  2. In ExmenApp.init(), after ActionService.initialize(), call SocketServer.shared.start()
  3. Socket should start listening immediately

  Optional: Add app termination handler to stop server cleanly (though socket file cleanup on start handles stale sockets).
  </action>
  <verify>
  1. Build and run app
  2. Check socket exists: ls -la ~/.config/exmen/exmen.sock
  3. Test with: echo '{"command":"list-actions"}' | nc -U ~/.config/exmen/exmen.sock
  </verify>
  <done>Socket server starts on app launch, responds to commands</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] Build succeeds without errors
- [ ] Socket file created at ~/.config/exmen/exmen.sock on app start
- [ ] `echo '{"command":"list-actions"}' | nc -U ~/.config/exmen/exmen.sock` returns JSON array
- [ ] `echo '{"command":"status","name":"..."}' | nc -U ...` returns action status
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- Socket server running and responding to JSON commands
- ActionService data accessible via IPC
  </success_criteria>

<output>
After completion, create `.planning/phases/06-ipc-server/06-01-SUMMARY.md`
</output>
