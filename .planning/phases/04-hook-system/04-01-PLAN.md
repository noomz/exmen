---
phase: 04-hook-system
plan: 01
type: execute
depends_on: []
files_modified: [Exmen/Models/ActionConfig.swift, Exmen/Models/Action.swift, Exmen/Models/HookUpdate.swift, Exmen/Services/HookParser.swift]
---

<objective>
Add hook system support to parse script output for dynamic updates (title, status, badge).

Purpose: Allow scripts to push updates to their action display via special output format.
Output: HookParser that extracts updates from script output, updated models to support hooks.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-plan.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-script-execution/03-02-SUMMARY.md

**Hook system requirements:**
- Scripts emit special format to update their display
- Format: `EXMEN:key=value` (one per line)
- Supported keys: title, status, badge, icon
- Updates should reflect in the UI without re-running the action
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create HookUpdate model</name>
  <files>Exmen/Models/HookUpdate.swift</files>
  <action>
Create a model to represent hook updates from script output:

```swift
import Foundation

/// Represents a dynamic update from a script's hook output
struct HookUpdate {
    var title: String?
    var status: String?
    var badge: String?
    var icon: String?

    /// Whether any update was received
    var hasUpdates: Bool {
        title != nil || status != nil || badge != nil || icon != nil
    }

    /// Merge another update into this one (newer values override)
    mutating func merge(_ other: HookUpdate) {
        if let title = other.title { self.title = title }
        if let status = other.status { self.status = status }
        if let badge = other.badge { self.badge = badge }
        if let icon = other.icon { self.icon = icon }
    }
}

/// Configuration for hook behavior in TOML
struct HookConfig: Codable {
    /// Script to run for status updates (optional)
    let statusScript: ScriptConfig?

    /// Polling interval in seconds (0 = disabled)
    let pollInterval: Int?

    /// Whether to parse main script output for hooks
    let parseOutput: Bool?

    enum CodingKeys: String, CodingKey {
        case statusScript = "status_script"
        case pollInterval = "poll_interval"
        case parseOutput = "parse_output"
    }

    /// Default poll interval (60 seconds)
    static let defaultPollInterval = 60

    /// Resolved poll interval
    var resolvedPollInterval: Int {
        pollInterval ?? Self.defaultPollInterval
    }

    /// Whether to parse output (default true)
    var shouldParseOutput: Bool {
        parseOutput ?? true
    }
}
```
  </action>
  <verify>HookUpdate.swift exists with HookUpdate and HookConfig structs</verify>
  <done>HookUpdate model created</done>
</task>

<task type="auto">
  <name>Task 2: Create HookParser service</name>
  <files>Exmen/Services/HookParser.swift</files>
  <action>
Create the parser for extracting hook updates from script output:

```swift
import Foundation

/// Parser for extracting hook updates from script output
class HookParser {
    static let shared = HookParser()

    /// Prefix for hook lines
    private let hookPrefix = "EXMEN:"

    private init() {}

    /// Parse script output for hook updates
    /// Format: EXMEN:key=value (one per line)
    /// Supported keys: title, status, badge, icon
    func parse(_ output: String) -> (cleanOutput: String, updates: HookUpdate) {
        var updates = HookUpdate()
        var cleanLines: [String] = []

        let lines = output.components(separatedBy: .newlines)

        for line in lines {
            if line.hasPrefix(hookPrefix) {
                // Parse hook line
                let hookContent = String(line.dropFirst(hookPrefix.count))
                if let (key, value) = parseKeyValue(hookContent) {
                    applyUpdate(key: key, value: value, to: &updates)
                }
            } else {
                // Keep non-hook lines for clean output
                cleanLines.append(line)
            }
        }

        let cleanOutput = cleanLines.joined(separator: "\n")
        return (cleanOutput, updates)
    }

    /// Parse a key=value string
    private func parseKeyValue(_ content: String) -> (key: String, value: String)? {
        guard let equalsIndex = content.firstIndex(of: "=") else {
            return nil
        }

        let key = String(content[..<equalsIndex]).trimmingCharacters(in: .whitespaces).lowercased()
        let value = String(content[content.index(after: equalsIndex)...]).trimmingCharacters(in: .whitespaces)

        guard !key.isEmpty, !value.isEmpty else {
            return nil
        }

        return (key, value)
    }

    /// Apply a parsed key-value to the updates struct
    private func applyUpdate(key: String, value: String, to updates: inout HookUpdate) {
        switch key {
        case "title":
            updates.title = value
        case "status":
            updates.status = value
        case "badge":
            updates.badge = value
        case "icon":
            updates.icon = value
        default:
            print("HookParser: Unknown key '\(key)'")
        }
    }
}
```
  </action>
  <verify>HookParser.swift exists with parse() method</verify>
  <done>HookParser service created</done>
</task>

<task type="auto">
  <name>Task 3: Update ActionConfig to support hooks</name>
  <files>Exmen/Models/ActionConfig.swift</files>
  <action>
Add hook configuration to ActionConfig:

Update the ActionConfig struct to include optional hook configuration:

```swift
// Add to ActionConfig struct:
let hook: HookConfig?
```

The full struct should now be:
```swift
struct ActionConfig: Codable {
    let name: String
    let icon: String?
    let description: String?
    let script: ScriptConfig
    let output: OutputConfig?
    let hook: HookConfig?  // NEW

    /// Default output handler if not specified
    var resolvedOutput: OutputConfig {
        output ?? OutputConfig(handler: .clipboard)
    }
}
```
  </action>
  <verify>ActionConfig has hook: HookConfig? property</verify>
  <done>ActionConfig updated with hook support</done>
</task>

<task type="auto">
  <name>Task 4: Update Action model to support dynamic updates</name>
  <files>Exmen/Models/Action.swift</files>
  <action>
Add hook-related properties to Action:

```swift
import Foundation

struct Action: Identifiable {
    let id: UUID
    let name: String
    let icon: String
    let description: String
    let scriptConfig: ScriptConfig?
    let outputConfig: OutputConfig
    let hookConfig: HookConfig?  // NEW

    // Dynamic state (can be updated by hooks)
    var dynamicTitle: String?      // NEW
    var dynamicStatus: String?     // NEW
    var dynamicBadge: String?      // NEW
    var dynamicIcon: String?       // NEW

    /// Display title (dynamic or static)
    var displayTitle: String {
        dynamicTitle ?? name
    }

    /// Display icon (dynamic or static)
    var displayIcon: String {
        dynamicIcon ?? icon
    }

    init(
        id: UUID = UUID(),
        name: String,
        icon: String = "terminal",
        description: String = "",
        scriptConfig: ScriptConfig? = nil,
        outputConfig: OutputConfig = OutputConfig(handler: .clipboard),
        hookConfig: HookConfig? = nil
    ) {
        self.id = id
        self.name = name
        self.icon = icon
        self.description = description
        self.scriptConfig = scriptConfig
        self.outputConfig = outputConfig
        self.hookConfig = hookConfig
    }

    /// Initialize from ActionConfig (loaded from TOML)
    init(from config: ActionConfig) {
        self.id = UUID()
        self.name = config.name
        self.icon = config.icon ?? "terminal"
        self.description = config.description ?? ""
        self.scriptConfig = config.script
        self.outputConfig = config.resolvedOutput
        self.hookConfig = config.hook
    }

    /// Apply hook updates to this action
    mutating func applyHookUpdate(_ update: HookUpdate) {
        if let title = update.title { dynamicTitle = title }
        if let status = update.status { dynamicStatus = status }
        if let badge = update.badge { dynamicBadge = badge }
        if let icon = update.icon { dynamicIcon = icon }
    }
}

// Static sample actions for development/fallback
extension Action {
    static let samples: [Action] = [
        Action(name: "Generate Phone Number", icon: "phone", description: "Generate random phone number"),
        Action(name: "Update Homebrew", icon: "arrow.clockwise", description: "Run brew update && upgrade"),
        Action(name: "Check Disk Space", icon: "internaldrive", description: "Show available disk space")
    ]
}
```
  </action>
  <verify>Action has hookConfig, dynamic properties, and applyHookUpdate method</verify>
  <done>Action model updated with hook support</done>
</task>

<task type="auto">
  <name>Task 5: Update Xcode project with new files</name>
  <files>Exmen.xcodeproj/project.pbxproj</files>
  <action>
Add HookUpdate.swift and HookParser.swift to the Xcode project:
- HookUpdate.swift in Models group
- HookParser.swift in Services group
  </action>
  <verify>Both files in project and build succeeds</verify>
  <done>Xcode project updated</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] HookUpdate.swift exists with HookUpdate and HookConfig
- [ ] HookParser.swift exists with parse() method
- [ ] ActionConfig.swift has hook: HookConfig?
- [ ] Action.swift has dynamic properties and applyHookUpdate
- [ ] Files added to Xcode project
- [ ] Project builds successfully
</verification>

<success_criteria>
- All tasks completed
- Can parse EXMEN:key=value from script output
- Action model supports dynamic title/status/badge/icon
- HookConfig can be defined in TOML
- Hook updates separated from clean output
</success_criteria>

<output>
After completion, create `.planning/phases/04-hook-system/04-01-SUMMARY.md`
</output>
