---
phase: 04-hook-system
plan: 02
type: execute
depends_on: ["04-01"]
files_modified: [Exmen/Services/ActionService.swift, Exmen/Services/StatusPoller.swift, Exmen/Views/MenuContentView.swift, Exmen/Views/ActionRowView.swift]
---

<objective>
Implement polling fallback for status updates and integrate hooks into UI.

Purpose: Actions with status_script can have their display updated periodically.
Output: StatusPoller that runs status scripts at intervals, UI shows dynamic status.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-plan.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-hook-system/04-01-SUMMARY.md

**Polling requirements:**
- Run status_script at poll_interval for actions that have hooks configured
- Parse output for EXMEN:key=value updates
- Update action's dynamic properties
- Refresh UI to show new status
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create StatusPoller service</name>
  <files>Exmen/Services/StatusPoller.swift</files>
  <action>
Create the status polling service:

```swift
import Foundation

/// Service for polling action status scripts
class StatusPoller {
    static let shared = StatusPoller()

    private var timers: [UUID: Timer] = [:]
    private weak var actionService: ActionService?

    private init() {}

    /// Start polling for all actions that have hook configs
    func startPolling(for actionService: ActionService) {
        self.actionService = actionService
        stopAll()

        for action in actionService.actions {
            if let hookConfig = action.hookConfig,
               let statusScript = hookConfig.statusScript {
                startPolling(for: action, script: statusScript, interval: hookConfig.resolvedPollInterval)
            }
        }
    }

    /// Start polling for a single action
    private func startPolling(for action: Action, script: ScriptConfig, interval: Int) {
        guard interval > 0 else { return }

        // Run immediately first
        Task {
            await runStatusScript(for: action.id, script: script)
        }

        // Then schedule periodic updates
        let timer = Timer.scheduledTimer(withTimeInterval: TimeInterval(interval), repeats: true) { [weak self] _ in
            Task {
                await self?.runStatusScript(for: action.id, script: script)
            }
        }

        timers[action.id] = timer
        print("StatusPoller: Started polling for '\(action.name)' every \(interval)s")
    }

    /// Run the status script and update the action
    private func runStatusScript(for actionId: UUID, script: ScriptConfig) async {
        do {
            let result = try await ScriptRunner.shared.run(script, timeout: 10)

            guard result.isSuccess else {
                print("StatusPoller: Status script failed for \(actionId)")
                return
            }

            let (_, updates) = HookParser.shared.parse(result.output)

            if updates.hasUpdates {
                await MainActor.run {
                    actionService?.applyHookUpdate(updates, to: actionId)
                }
            }
        } catch {
            print("StatusPoller: Error running status script: \(error)")
        }
    }

    /// Stop polling for a specific action
    func stopPolling(for actionId: UUID) {
        timers[actionId]?.invalidate()
        timers.removeValue(forKey: actionId)
    }

    /// Stop all polling
    func stopAll() {
        for timer in timers.values {
            timer.invalidate()
        }
        timers.removeAll()
    }

    /// Restart polling (called when actions are reloaded)
    func restart() {
        if let actionService = actionService {
            startPolling(for: actionService)
        }
    }
}
```
  </action>
  <verify>StatusPoller.swift exists with startPolling, stopAll methods</verify>
  <done>StatusPoller service created</done>
</task>

<task type="auto">
  <name>Task 2: Update ActionService to support hook updates</name>
  <files>Exmen/Services/ActionService.swift</files>
  <action>
Add hook update support to ActionService:

```swift
import Foundation
import SwiftUI

/// Main service for managing actions
@MainActor
class ActionService: ObservableObject {
    static let shared = ActionService()

    @Published var actions: [Action] = []
    @Published var isLoading = false
    @Published var lastError: String?

    private let configLoader = ConfigLoader.shared
    private var directoryWatcher: DirectoryWatcher?

    private init() {}

    /// Initialize the service - load actions and start watching
    func initialize() {
        _ = configLoader.ensureConfigDirectory()
        loadActions()
        startWatching()
    }

    /// Load actions from config files
    func loadActions() {
        isLoading = true
        lastError = nil

        let configs = configLoader.loadAllConfigs()

        if configs.isEmpty {
            actions = Action.samples
            print("ActionService: No configs found, using sample actions")
        } else {
            actions = configs.map { Action(from: $0) }
            print("ActionService: Loaded \(actions.count) actions from config")
        }

        isLoading = false

        // Start status polling for actions with hooks
        StatusPoller.shared.startPolling(for: self)
    }

    /// Apply a hook update to a specific action
    func applyHookUpdate(_ update: HookUpdate, to actionId: UUID) {
        guard let index = actions.firstIndex(where: { $0.id == actionId }) else {
            return
        }
        actions[index].applyHookUpdate(update)
    }

    /// Apply hook update from script result
    func processScriptResult(_ result: ScriptResult, for action: Action) -> (cleanOutput: String, updates: HookUpdate) {
        guard action.hookConfig?.shouldParseOutput ?? true else {
            return (result.output, HookUpdate())
        }

        let parsed = HookParser.shared.parse(result.output)

        if parsed.updates.hasUpdates {
            applyHookUpdate(parsed.updates, to: action.id)
        }

        return parsed
    }

    /// Start watching the config directory for changes
    func startWatching() {
        directoryWatcher = DirectoryWatcher(
            path: configLoader.configDirectory
        ) { [weak self] in
            print("ActionService: Config directory changed, reloading...")
            self?.loadActions()
        }

        if directoryWatcher?.start() == false {
            print("ActionService: Could not start directory watcher")
        }
    }

    /// Stop watching for changes
    func stopWatching() {
        directoryWatcher?.stop()
        directoryWatcher = nil
        StatusPoller.shared.stopAll()
    }

    /// Manually trigger a reload
    func refresh() {
        loadActions()
    }
}
```
  </action>
  <verify>ActionService has applyHookUpdate and processScriptResult methods</verify>
  <done>ActionService updated with hook support</done>
</task>

<task type="auto">
  <name>Task 3: Extract ActionRowView to separate file</name>
  <files>Exmen/Views/ActionRowView.swift</files>
  <action>
Create a separate file for ActionRowView with dynamic display support:

```swift
import SwiftUI

struct ActionRowView: View {
    let action: Action
    let isExecuting: Bool
    let onExecute: () -> Void

    @State private var isHovered = false

    var body: some View {
        Button(action: onExecute) {
            HStack(spacing: 12) {
                // Icon or loading spinner
                if isExecuting {
                    ProgressView()
                        .scaleEffect(0.7)
                        .frame(width: 20)
                } else {
                    Image(systemName: action.displayIcon)
                        .frame(width: 20)
                        .foregroundColor(.accentColor)
                }

                // Title and description/status
                VStack(alignment: .leading, spacing: 2) {
                    HStack(spacing: 4) {
                        Text(action.displayTitle)
                            .font(.body)

                        // Badge if present
                        if let badge = action.dynamicBadge {
                            Text(badge)
                                .font(.caption2)
                                .padding(.horizontal, 4)
                                .padding(.vertical, 1)
                                .background(Color.accentColor.opacity(0.2))
                                .cornerRadius(4)
                        }
                    }

                    // Status or description
                    if let status = action.dynamicStatus {
                        Text(status)
                            .font(.caption)
                            .foregroundColor(.accentColor)
                    } else if !action.description.isEmpty {
                        Text(action.description)
                            .font(.caption)
                            .foregroundColor(.secondary)
                    }
                }

                Spacer()

                // Play icon on hover
                Image(systemName: "play.fill")
                    .font(.caption)
                    .foregroundColor(.secondary)
                    .opacity(isHovered && !isExecuting ? 1 : 0)
            }
            .padding(.vertical, 8)
            .padding(.horizontal, 12)
            .background(isHovered ? Color.accentColor.opacity(0.1) : Color.clear)
            .cornerRadius(6)
        }
        .buttonStyle(.plain)
        .disabled(isExecuting)
        .onHover { hovering in
            isHovered = hovering
        }
    }
}
```
  </action>
  <verify>ActionRowView.swift exists with dynamic display support</verify>
  <done>ActionRowView extracted with dynamic display</done>
</task>

<task type="auto">
  <name>Task 4: Update MenuContentView to use hook processing</name>
  <files>Exmen/Views/MenuContentView.swift</files>
  <action>
Update MenuContentView to process hooks from script results:

```swift
import SwiftUI

struct MenuContentView: View {
    @ObservedObject private var actionService = ActionService.shared
    @State private var executingActionId: UUID?
    @State private var popupResult: (action: Action, result: ScriptResult, cleanOutput: String)?

    var body: some View {
        VStack(spacing: 0) {
            // Header
            HStack {
                Image(systemName: "terminal.fill")
                    .foregroundColor(.accentColor)
                Text("Exmen")
                    .font(.headline)
                Spacer()
                Button(action: {
                    actionService.refresh()
                }) {
                    Image(systemName: "arrow.clockwise")
                        .font(.caption)
                }
                .buttonStyle(.plain)
                .help("Reload actions")
            }
            .padding()

            Divider()

            // Actions list or popup
            if let popup = popupResult {
                PopupResultView(
                    actionName: popup.action.name,
                    result: popup.result,
                    cleanOutput: popup.cleanOutput,
                    onDismiss: { popupResult = nil }
                )
            } else if actionService.isLoading {
                ProgressView()
                    .frame(maxWidth: .infinity, maxHeight: .infinity)
            } else if actionService.actions.isEmpty {
                Text("No actions configured")
                    .foregroundColor(.secondary)
                    .frame(maxWidth: .infinity, maxHeight: .infinity)
            } else {
                ScrollView {
                    LazyVStack(spacing: 4) {
                        ForEach(actionService.actions) { action in
                            ActionRowView(
                                action: action,
                                isExecuting: executingActionId == action.id,
                                onExecute: { executeAction(action) }
                            )
                        }
                    }
                    .padding(.vertical, 8)
                    .padding(.horizontal, 12)
                }
            }

            Divider()

            // Footer
            HStack {
                Text("v1.0")
                    .font(.caption)
                    .foregroundColor(.secondary)
                Spacer()
                Button("Quit") {
                    NSApp.terminate(nil)
                }
                .keyboardShortcut("q", modifiers: .command)
            }
            .padding(12)
        }
        .frame(width: popupResult != nil ? 400 : 280, height: popupResult != nil ? 350 : 320)
    }

    private func executeAction(_ action: Action) {
        guard let scriptConfig = action.scriptConfig else {
            print("No script config for action: \(action.name)")
            return
        }

        executingActionId = action.id

        Task {
            do {
                let result = try await ScriptRunner.shared.run(scriptConfig)

                await MainActor.run {
                    executingActionId = nil
                    handleResult(result, for: action)
                }
            } catch {
                await MainActor.run {
                    executingActionId = nil
                    let errorResult = ScriptResult(
                        output: "",
                        error: error.localizedDescription,
                        exitCode: -1,
                        duration: 0
                    )
                    handleResult(errorResult, for: action)
                }
            }
        }
    }

    private func handleResult(_ result: ScriptResult, for action: Action) {
        // Process hooks and get clean output
        let (cleanOutput, _) = actionService.processScriptResult(result, for: action)

        // Create a modified result with clean output for display
        let displayResult = ScriptResult(
            output: cleanOutput,
            error: result.error,
            exitCode: result.exitCode,
            duration: result.duration
        )

        switch action.outputConfig.handler {
        case .clipboard:
            OutputService.shared.copyToClipboard(cleanOutput.trimmingCharacters(in: .whitespacesAndNewlines))
            if result.isSuccess {
                OutputService.shared.showNotification(
                    title: action.name,
                    body: "Copied to clipboard",
                    isError: false
                )
            }
        case .notification:
            OutputService.shared.showNotification(
                title: action.name,
                body: cleanOutput.trimmingCharacters(in: .whitespacesAndNewlines),
                isError: !result.isSuccess
            )
        case .popup:
            popupResult = (action, displayResult, cleanOutput)
        }
    }
}

#Preview {
    MenuContentView()
}
```
  </action>
  <verify>MenuContentView processes hooks and uses clean output</verify>
  <done>MenuContentView updated with hook processing</done>
</task>

<task type="auto">
  <name>Task 5: Update PopupResultView for clean output</name>
  <files>Exmen/Views/PopupResultView.swift</files>
  <action>
Update PopupResultView to accept clean output:

```swift
import SwiftUI

/// View for displaying script result in a popup
struct PopupResultView: View {
    let actionName: String
    let result: ScriptResult
    let cleanOutput: String
    let onDismiss: () -> Void

    var body: some View {
        VStack(spacing: 0) {
            // Header
            HStack {
                Image(systemName: result.isSuccess ? "checkmark.circle.fill" : "xmark.circle.fill")
                    .foregroundColor(result.isSuccess ? .green : .red)
                Text(actionName)
                    .font(.headline)
                Spacer()
                Button(action: onDismiss) {
                    Image(systemName: "xmark")
                        .foregroundColor(.secondary)
                }
                .buttonStyle(.plain)
            }
            .padding()

            Divider()

            // Output content
            ScrollView {
                VStack(alignment: .leading, spacing: 8) {
                    if !cleanOutput.isEmpty {
                        Text(cleanOutput)
                            .font(.system(.body, design: .monospaced))
                            .textSelection(.enabled)
                            .frame(maxWidth: .infinity, alignment: .leading)
                    }

                    if !result.error.isEmpty {
                        Text(result.error)
                            .font(.system(.body, design: .monospaced))
                            .foregroundColor(.red)
                            .textSelection(.enabled)
                            .frame(maxWidth: .infinity, alignment: .leading)
                    }

                    if cleanOutput.isEmpty && result.error.isEmpty {
                        Text("No output")
                            .foregroundColor(.secondary)
                            .italic()
                    }
                }
                .padding()
            }

            Divider()

            // Footer
            HStack {
                Text("Exit code: \(result.exitCode)")
                    .font(.caption)
                    .foregroundColor(.secondary)
                Text("â€¢")
                    .foregroundColor(.secondary)
                Text(String(format: "%.2fs", result.duration))
                    .font(.caption)
                    .foregroundColor(.secondary)
                Spacer()
                Button("Copy") {
                    OutputService.shared.copyToClipboard(cleanOutput.trimmingCharacters(in: .whitespacesAndNewlines))
                }
                Button("Close") {
                    onDismiss()
                }
                .keyboardShortcut(.escape, modifiers: [])
            }
            .padding(12)
        }
        .frame(width: 400, height: 300)
    }
}
```
  </action>
  <verify>PopupResultView accepts cleanOutput parameter</verify>
  <done>PopupResultView updated</done>
</task>

<task type="auto">
  <name>Task 6: Create sample TOML with hook config</name>
  <files>~/.config/exmen/actions/</files>
  <action>
Create a sample action with hook configuration:

**File: ~/.config/exmen/actions/system-status.toml**
```toml
name = "System Status"
icon = "cpu"
description = "Check CPU and memory usage"

[script]
type = "inline"
content = """
#!/bin/bash
# Get CPU usage
cpu=$(top -l 1 | grep "CPU usage" | awk '{print $3}')
# Get memory
mem=$(memory_pressure | grep "System-wide memory free percentage" | awk '{print $5}')
echo "CPU: $cpu | Mem: ${mem:-N/A}"
"""

[output]
handler = "notification"

[hook]
poll_interval = 30
parse_output = true

[hook.status_script]
type = "inline"
content = """
#!/bin/bash
cpu=$(top -l 1 | grep "CPU usage" | awk '{print $3}' | tr -d '%')
if [ "${cpu%.*}" -gt 50 ]; then
    echo "EXMEN:badge=HIGH"
    echo "EXMEN:status=CPU: ${cpu}%"
else
    echo "EXMEN:status=CPU: ${cpu}%"
fi
"""
```
  </action>
  <verify>system-status.toml exists with hook config</verify>
  <done>Sample hook config created</done>
</task>

<task type="auto">
  <name>Task 7: Update Xcode project</name>
  <files>Exmen.xcodeproj/project.pbxproj</files>
  <action>
Add new files to Xcode project:
- StatusPoller.swift in Services group
- ActionRowView.swift in Views group
  </action>
  <verify>All files in project and build succeeds</verify>
  <done>Xcode project updated</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] StatusPoller.swift exists with polling logic
- [ ] ActionService.swift has hook update methods
- [ ] ActionRowView.swift shows dynamic properties
- [ ] MenuContentView processes hooks
- [ ] PopupResultView uses clean output
- [ ] Sample system-status.toml created
- [ ] Files added to Xcode project
- [ ] Project builds successfully
</verification>

<success_criteria>
- All tasks completed
- Actions can have status scripts that run periodically
- Script output can include EXMEN:key=value for updates
- UI displays dynamic title, status, badge
- Clean output (without hook lines) shown to user
- Phase 4 Hook System complete
</success_criteria>

<output>
After completion, create `.planning/phases/04-hook-system/04-02-SUMMARY.md`

Note: This completes Phase 4 and the entire v1 roadmap. Mark phase as complete in ROADMAP.md.
</output>
